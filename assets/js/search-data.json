{
  
    
        "post0": {
            "title": "Number of tiny pairs",
            "content": "Problem . You are given two arrays of integers and b of the same length, and an integer k. We will be iterating through array a from left to right, and simultaneously through array b from right to left, and looking at pairs (x, y) where x is from a and y is from b. Such pair is called tiny if the concatenation xy is strictly less than k . Your task is to return the number of tiny pairs that you’ll encounter during the simultaneous iteration through a and b. . Example . Example 1 . For [1, 2, 3] b = (1, 2, 3) and k = 31 , the output should be solution(a, b, k) = 2 . We’re considering the following pairs during iteration: . (1, 3) : Their concatenation equals 13, which is less than 31 SO the pair iS tiny; | (2 2) : Their concatenation equals 22 , which is less than 31 so the IS pair is tiny; | (3, 1) : Their concatenation equals 31 which is not less than 31 so the pair is not tiny. | . As you can see, there are 2 tiny pairs during the iteration, so the answer is 2. . Example 2 . For a[16, 14] , b = [7, 11, 2, 15] , and k = 743 , the output should be solution (a, b, k) = 4 . We’re considering the Following pairs during iteration: . (16, 15) : Their concatenation equals 1615 , which is greater than 743, so the pair is not tiny; | (1, 0) : Their concatenation equals 10 , which is less than 743, so the pair is tiny; | (4, 2) : Their concatenation equals 42 , which is less than 743, so the pair is tiny. | (2, 11) : Their concatenation equals 211 , which is less than 743, so the pair is tiny; | (14, 7) : Their concatenation equals 147 which is less than 743 , so the pair is tiny. | . There are 4 tiny pairs during the iteration. So the answer is 4 . Pseudocode . fun (a[i], b[j], k) str_a = str(a[i]) str_b = srt(b[i]) res_str = str_a + str_b return int(res_str) &lt; k main() i=0, j=len (b) =1 while i&lt;len(a) and j&lt;=0: if fun(a[i], b[i], k): count++ i+=1, j-=1 return count . Implementation . def helper(a, b, k): str_a = str(a) str_b = str(b) res_str = str_a + str_b return int(res str) &lt; k def solution(a, b, k): i = 0 j = len(b)-1 count = 0 while i&lt;len(a) and j&gt;=0: if helper(a[i], b[j], k): count = count+1 i+=1 j-=1 return count .",
            "url": "https://archanakalburgi.github.io/code_challenges/array/tiny_pairs/2022/01/21/tiny_pairs.html",
            "relUrl": "/array/tiny_pairs/2022/01/21/tiny_pairs.html",
            "date": " • Jan 21, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Calculate a boolean array",
            "content": "Question . You are given an array of integers a and two integers l and r. You task is to calculate a boolean array b, where b[i] = true if there exists an integer x, such that a[i] = (i + 1) * x and l&lt;= x &lt;= r. Otherwise, b[i] should be set to false . Example . For a = [8, 5, 6, 16, 51], l = 1, and r = 3, the output should be solution (a, l, r) = [false, false, true, false, true]. . For a[0] = 8 , we need to find a value of x such that 1 * x = 8, but the only value that would work is x = 8 which doesn’t satisfy the boundaries 1 &lt;= x &lt;= 3, so b[0] = false. | For a[1] = 5, we need to find a value of x such that 2 * x = 5, but there is no integer value that would satisfy this equation, so b[1] = false | For a[2] = 6, we can choose x because 3 * 2 = 6 and 1 &lt;= 2 &lt;= 3, so b[2] = true | For a[3] = 16, there is no an integer 1 &lt;= x &lt;= 3 , such that 4 * x = 16, so b[3] = false. | For a[4] = 5, we can choose x = 1 because 5 * 1 = 5 and 1 &lt;= 1 &lt;= 3 , so b[4] = true. | . Guaranteed constraints: . 1 &lt;= a.length &lt;= 100 | 1 &lt;= a[i] &lt;= 10^6 | 1 &lt;= l &lt;= 10^4 | 1 &lt;= r &lt;= 10^4 | . Pseudocode . func (i, a[i], l, r): for x in range(l, r+1): if (i+1)*x == a[i]: return true return false main() iterate a fun (i,ali], l,r)-&gt; t b=&gt; append bool return b . Implementation . def helper (i, num, l, r): for in range(l, r+1): if (i+1)*x == num: return True return False def solution(a, l, r): b = list() for i in range(len(a)): res = helper(i, a[i], l, r) b.append(res) return b .",
            "url": "https://archanakalburgi.github.io/code_challenges/array_construction/2022/01/21/contruct_array.html",
            "relUrl": "/array_construction/2022/01/21/contruct_array.html",
            "date": " • Jan 21, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Walls and gates - omg to om!",
            "content": ". image source . In my previous blog post, I implemented an O(omg) time complexity solution, well soon I discovered that the solution can be further optimized and the time complexity can be reduced from omg to om. OMG right!? . What made the previous implementation’s time complexity omg? . def wallsAndGates(rooms): for row in range(len(rooms)): for column in range(len(rooms[0])): if rooms[row][column] == 0: bfs(row, column, rooms) . BFS is called on every gate in the matrix . if rooms[row][column] == 0: bfs(row, column, rooms) . Even though the time complexity of BFS is O(om), calling it on every gate in the grid make the overall implementation an O(omg) solution Instead of starting BFS on every gate, starting BFS from the first gate and updating the values of cells with the shortest distance will reduce the time complexity This is how modified the previous implementation . def valid_neighbors(r,c,row,col): valid = [] neighbors = [(r,c-1),(r,c+1),(r-1,c),(r+1,c)] for (nr,nc) in neighbors: if 0 &gt;= nr &gt; row and 0 &gt;= nc &gt; col: valid.append((nr,nc)) return valid def bfs(row,col,rooms): queue = [(row, col, 0)] visited = set((row,col)) while queue: r,c,dist = queue.pop(0) for (nr, nc) in valid_neighbors(r,c,rooms): if (nr,nc) not in visited: if rooms[nr][nc] &gt; dist: rooms[nr][nc] = dist+1 queue.append((nr,nc,dist+1)) visited.add((nr,nc)) def wallsAndGates(rooms): ro = len(rooms) column = len(rooms[0]) for row in range(ro): for col in range(column): if rooms[row][col] == 0: bfs(row,col,rooms) . with this implementation, we are checking the cell once and update the value only if the current distance is smaller than the value in the cell. | what I found very delightful is that we do not have to worry about the 0 and -1 value in the cell, which represents a gate and a wall because 0 or -1 cannot be greater than the distance | the following condition in bfs() function will take care of the above | . if rooms[nr][nc] &gt; dist . Hope you find this post interesting!! .",
            "url": "https://archanakalburgi.github.io/code_challenges/graph/bfs/2022/01/21/walls-and-gates2.html",
            "relUrl": "/graph/bfs/2022/01/21/walls-and-gates2.html",
            "date": " • Jan 21, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Find and Replace Pattern",
            "content": "Problem statements . Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order. . A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. . Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter. . Examples . Example 1: . Input: words = [“abc”,”deq”,”mee”,”aqq”,”dkd”,”ccc”], pattern = “abb” Output: [“mee”,”aqq”] Explanation: “mee” matches the pattern because there is a permutation {a -&gt; m, b -&gt; e, …}. “ccc” does not match the pattern because {a -&gt; c, b -&gt; c, …} is not a permutation, since a and b map to the same letter. . Example 2: . Input: words = [“a”,”b”,”c”], pattern = “a” Output: [“a”,”b”,”c”] . Solution using UMPIRE . Test cases . words = [qnr, anr, nmr] pattern = xnr output = [ qnr, anr, nmr ] words = [] -&gt; X pattern = pq words = [p, f, b] -&gt; X pattern = &quot;&quot; words = [ab, dg, pn] -&gt; X pattern = abc words = [ASD, 990] -&gt; X patter -&gt; 889 -&gt; X words = [abc, pqr] patter = rrr output = [ ] words = [&quot;abcde&quot;,&quot;meeme&quot;] pattern = &quot;abbab&quot; . Match and Plan . abbab a:0,3 b:1,2,4 meeme m:0,3 e:1,2,4 . helper(string): map = {} res = &quot;&quot; iterate string: i if string[i] in map: map[string]: ..i else map[string]:i iterate string: s res += map[s] return res main() result=[] pattern_encoded = helper(pattern) iterate words: word word_pattern = helper(word) if word_pattern == pattern_encoded: result: add - word return result . Implement . class Solution: def helper(self, string): mapping = dict() encoded_pattern = &quot;&quot; for i in range(len(string)): if string[i] in mapping: mapping[string[i]].append(i) else: mapping[string[i]] = [i] for s in string: for i in mapping[s]: encoded_pattern += str(i) return encoded_pattern def findAndReplacePattern(self, words: List[str], pattern: str) -&gt; List[str]: result = list() pattern_encoded = self.helper(pattern) for word in words: word_encoded = self.helper(word) if len(word) == len(pattern) and word_encoded == pattern_encoded: result.append(word) return result . Review and Evaluate . Complexity : Let N = length of words and K = length of each word in words . Time complexity: O(N*K) | . | Space complexity: O(N*K) | . | .",
            "url": "https://archanakalburgi.github.io/code_challenges/pattern_matching/string_pattern/2022/01/18/find_pattern.html",
            "relUrl": "/pattern_matching/string_pattern/2022/01/18/find_pattern.html",
            "date": " • Jan 18, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "Walls and gates - Breadth first search",
            "content": ". image source . Problem statement . Given a m x n grid rooms initialized with these three possible values. . -1 A wall or an obstacle. | 0 A gate. | INF Infinity means an empty room. We use the value 2 31 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647. | . Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF. . Understand . Example 1: . . Example 2: . . Example 3: . . Match and plan . From the gate we have to go to the neighboring cells and mark the cells with the shortest distance from the nearest gate | This is graph problem where we have to traverse the given matrix and update the values in the cells | We can traverse the matrix with BFS or DFS way | I have used BFS to traverse the matrix because we have to find the shortest distance and BFS will help us find the shortest distance | . Logical steps: . from main function call BFS function | source cell is the fist cell with value = 0 (gate) | go to neighbors of the source and change the value of the neighboring cell with minimum(value of cell, distance) | perform above step only if value != -1 (wall) | value != 0 (gate) | if cell is not visited | | . So the first wo conditions where we are avoiding visiting a cell is the additional conditions we must take care in solving this problem . Implement . def valid_neighbors(r,c,row,col): valid = [] neighbors = [(r,c-1),(r,c+1),(r-1,c),(r+1,c)] for (nr,nc) in neighbors: if row &gt; nr &gt;= 0 and col &gt; nc &gt;= 0: valid.append((nr,nc)) return valid def bfs(ro, col, rooms): visited = set() queue = [(ro, col)] visited.add((ro,col)) distance = 0 while queue: for _ in range(len(queue)): ro, col = queue.pop(0) rooms[ro][col] = min(rooms[ro][col], distance) for (nr,nc) in valid_neighbors(ro, col, len(rooms), len(rooms[0])): if (nr,nc) not in visited and rooms[nr][nc] != -1 and rooms[nr][nc] != 0: queue.append((nr,nc)) visited.add((nr,nc)) distance +=1 def wallsAndGates(rooms): for row in range(len(rooms)): for column in range(len(rooms[0])): if rooms[row][column] == 0: bfs(row, column, rooms) . After discussing the above implementation with a few of my friends, I found their suggestions regarding implementing the code to get the valid neighbors of a cell helpful and adopted the following, which much easier to understand and read. | . def valid_neighbors(r,c,row,col): valid = [] neighbors = [(r,c-1),(r,c+1),(r-1,c),(r+1,c)] for (nr,nc) in neighbors: if 0 &lt;= nr &lt; row and 0 &lt;= nc &lt; col: valid.append((nr,nc)) return valid . notice something about the “if condition”? . Alternatively . one might think of implementing the following logic to update the distance in the cell . for (nr,nc) in valid_neighbors(ro, col, len(rooms), len(rooms[0])): if rooms[nr][nc] &gt; distance: rooms[nr][nc] = distance+1 queue.append((nr,nc,distance+1)) . in the above scenario we are not checking if the cells are already visited, instead checking if the values is the cell is greater than distance which works fine but it takes a longer computational time for a much bigger matrix as we are have to visit all the cells | in order to avoid this we could update the cell with min(rooms[ro][col], distance) and amend our code as follows | . rooms[ro][col] = min(rooms[ro][col], distance) for (nr,nc) in valid_neighbors(ro, col, len(rooms), len(rooms[0])): if (nr,nc) not in visited and rooms[nr][nc] != -1 and rooms[nr][nc] != 0: queue.append((nr,nc)) visited.add((nr,nc)) distance +=1 . Evaluate . Complexity . time: O(omg), where o = number of rows, m = number of columns and g = number of gates BFS takes m*n steps to reach a all rooms a gate | BFS from every single gate | . | space: O(om), where o is number of rows and m is number of columns we are making use of a queue in BFS to explore the unvisited cells | visited set | . | . Leaving with a question: How can we optimize time complexity and make it O(om). I shall explore this in my next post .",
            "url": "https://archanakalburgi.github.io/code_challenges/bfs/optimal/2021/09/11/walls-gates.html",
            "relUrl": "/bfs/optimal/2021/09/11/walls-gates.html",
            "date": " • Sep 11, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "Validate subsequence",
            "content": "Solving this problem helped me understand the order of techniques I can explore to arrive at the solution for an array problem. . . Problem statement . Given two non-empty arrays of integers, write a function that determines whether the second array is a subsequence of the first one. . A subsequence of an array is a set od numbers that aren’t necessarily adjacent in the array but that are in the same order as they appear in the array. . Understand . Input: . array = [1,2,3,4,5,6,7,8], | subsequence = [3,5,7] Output: true | . Input: . array: [10,20,30,40,50] | subsequence: [40] Output: true | . Input: . array = [11,11,11,11] | subsequence: [12,13,14] Output: false | . Input: . array: [5,1,22,25,6,-1,8,10] | subsequence: [1,6,-1,-2] Output: false | . Input: . array: [] | subsequence: [2,4,5] Output: Invalid case | . Match and Plan . List . iterate subsequence check for the numbers of subsequence are also present in input array and are in same order | O(n^2) solution | NOTE: with this plan, we cannot handle the duplicate numbers in the array of in the sequence | . Linked List . complicates the solution | . Sets . with sets we cannot: handle the duplicate values | maintain the order of numbers | . | . Dictionaries . iterate through sequence | build a hashmap, if keys are numbers of the sequence and values are the index of the number in sequence will fail in handling duplicate numbers | . | if keys are the index of the numbers in the sequence and values are the numbers themselves we won’t be able to check if a number in array is present in dictionary in constant time | . | . | . Techniques . build an array of all the possible sequence of the input array | check if the given subsequence is present in the array of all the possible sequence of the input array | . Pointers with pointers we can compare two numbers in the array and condition their movement accordingly. Pointers can also optimize the solution by not taking extra space . initialize two index pointers to 0 | let one index pointer point to the numbers in sequence and the other to the numbers in array | if array[array_index] == sequence[sequence_index], increment sequence_index to check the next number in the sequence | increment array_index regardless | return true of all the numbers in the sequence are covered | . Implement . def isValidSubsequence(array, sequence): arr_idx = 0 seq_idx = 0 while arr_idx &lt; len(array) and seq_idx &lt; len(sequence): if sequence[seq_idx] == array[arr_idx]: seq_idx += 1 arr_idx += 1 return seq_idx == len(sequence) . Review . lets dry run the code with the following test case: array = [1,2,3], sequence = [1,3] . . Evaluate . Complexity: . time: O(n), where n = len(array) | space: O(1) | .",
            "url": "https://archanakalburgi.github.io/code_challenges/2021/08/23/validate-subsequence.html",
            "relUrl": "/2021/08/23/validate-subsequence.html",
            "date": " • Aug 23, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "Three number sum",
            "content": "Another example that shows the time and space complexity trade off . . image source . Problem statement . Write a function that takes in a non-empty array of distinct integers and an integer representing a target sum. The function should find all the triplets in the array that sum up to the target sum and return a two-dimensional array of all these triplets. The numbers in each triplet should be ordered in ascending order, and the triplets themselves should be ordered in ascending order with respect to the numbers they hold. . If no three numbers sum up to the target sum, the function should return an empty array . Understand . Input: array = [12,3,1,2,-6,5,-8,6], target = 0 Output: [[-8,2,6],[-8,3,5],[-8,1,5]] . Input: array = [4,1,3], target = 8 Output: [[1,3,4]] . Input: [1,4,2,3,1], target = 6 Output: [[1,1,4],[1,2,3]] . Input: array = [4,1,3], target = 10 Output: [] . Input: [1,2], target = 5 Output: [] . Match and Plan . List . the first solution that comes to mind is iterating the list thrice to get the desired three numbers | we could do so in the following way . Plan // result = [] // for i -&gt; 0-len(array): // for i -&gt; i-len(array): //for k -&gt; j-len(array): if array[i]+array[j]+array[k] == targetSum result -&gt; sort[array[i], array[j],array[k]] // return sort(result) . complexity time: O(n3) + O(3 log(3)) + O(r log(r)) -&gt; O(n3), where n=len(array), r=len(result) | space: O(r), where r=len(result) | . | . | . | . Linked list . linked will complicate the solution by increasing the time and space complexity | . Hashmap . while we are iterating the array we will check if targetSum - (array[i]+array[j]) is in the hashmap | targetSum - (array[i]+array[j]) is essentially the third number of the triplet | if present in hashmap, remember the sorted order of array[i], array[j] and targetSum-(array[i]+array[j] | if not present then map array[j] to array[i], targetSum - (array[i] + array[j]) | we are essentially trying to sum two number of the array and looking if the third number through process . Plan // result = [] // for i -&gt; 0-len(array) // hashmap = {} // for j -&gt; i-len(array) if targetSum - (array[i] + array[j]) in hashmap result -&gt; sort([array[i],array[j],targetSum-(array[i]+array[j])) else: hashmap[array[j]] -&gt; array[i],targetSum - (array[i] + array[j]) // return sort(result) . complexity time: O(n2) + O(3 log(3)) + O(r log(r)) -&gt; O(n2), where n=len(array), r=len(result) | space: O(r), where r=len(result) | . | . | . | making use of hashmap we have managed to reduce the time complexity from O(n3) to O(n2) | the above is implemented using hashmap | . Sets . there is not need to store hashmap[array[j]]:array[i],targetSum - (array[i] + array[j]), since we are only interested in knowing the third number of the triplet | to avoid storing the mapping we can use set which will give us a constant time look up while not consuming extra space by just storing the numbers we have iterated through | . Exploring the techniques involved in traversing the array helped me arrive at the following plan . Technique . Three pointer approach: . idea behind using three pointers: if we have a sorted array, we can place a start pointer on the number to the right of the current number and end pointer at the last number in the array | check if current number + array[start] + array[end] == targetSum | if start is incremented by 1 will increment the sum(current number + array[start] + array[end]) | where as decrementing the end by 1 will reduce the sum(current number + array[start] + array[end]) | with this information we can obtain the list of triplets ([current number, array[start], array[end]]) which sum up to the targetSum . | Plan // sort given array // result = [] // for: i -&gt; 0-len(array)-2 start = i+1 end = len(array)-1 while start&lt;end: current_sum = array[i]+array[start]+array[end] if current_sum == targetSum result.append([array[i],array[start],array[end]]) move pointers close to each other by increasing start by 1 and decreasing end by 1 if current_sum &lt; targetSum move start pointer by increasing start by 1 if current_sum &gt; targetSum: move end pointer by decreasing end by 1 // return result . complexity time: O(n2), where n=len(array) | space: O(3n) -&gt; O(n), where n=len(array) | . | . | . | . Implementation and Evaluate . let’s implement all the above discussed solutions | . def threeNumberSum(array, targetSum): result = [] for i in range(len(array)): for j in range(i+1,len(array)): for k in range(j+1,len(array)): if array[i] + array[j] + array[k] == targetSum: result.append(sorted([array[i],array[j],array[k]])) return sorted(result) . complexity time: O(n3) + O(3 log(3)) + O(r log(r)) -&gt; O(n3), where n=len(array), r=len(result) | space: O(3n) -&gt; O(n), where n=len(array) | . | . def threeNumberSum(array, targetSum): result = [] for i in range(len(array)): temp = dict() for j in range(i+1,len(array)): if targetSum - (array[i] + array[j]) in temp: result.append(sorted((array[i],array[j],targetSum - (array[i] + array[j])))) else: temp[array[j]] = array[i],targetSum - (array[i] + array[j]) return sorted(result) . complexity time: O(n2) + O(3 log(3)) + O(r log(r)) -&gt; O(n2), where n=len(array), r=len(result) | space: O(n+2) + O(n) -&gt; O(n), where n=len(array) | . | . def threeNumberSum(array, targetSum): result = [] for i in range(len(array)): temp = set() # s: O(n) for j in range(i+1,len(array)): if targetSum-(array[i]+array[j]) in temp: result.append(sorted([array[i],array[j],targetSum-(array[i]+array[j])])) else: temp.add(array[j]) return sorted(result) . complexity time: O(n2) + O(3 log(3)) + O(r log(r)) -&gt; O(n2), where n=len(array), r=len(result) | space: O(n) + O(3n) -&gt; O(n), where n=len(array) | . | . def threeNumberSum(array, targetSum): # three pointer approach array.sort() result = [] for i in range(len(array)-2): start = i+1 end = len(array)-1 while start&lt;end: current_sum = array[i]+array[start]+array[end] if current_sum == targetSum: result.append([array[i],array[start],array[end]]) start += 1 end -= 1 elif current_sum &lt; targetSum: start += 1 elif current_sum &gt; targetSum: end -= 1 return result . complexity time: O(n2), where n=len(array) | space: O(3n) -&gt; O(n), where n=len(array) | . | .",
            "url": "https://archanakalburgi.github.io/code_challenges/three_number_sum/array/2021/08/17/three-number-sum.html",
            "relUrl": "/three_number_sum/array/2021/08/17/three-number-sum.html",
            "date": " • Aug 17, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "Two number sum",
            "content": "Following is one of the many array questions and is a good example that shows the time and space complexity trade off . . image source . Problem statement . Write a function that takes in a non-empty array of distinct integers and an integer representing a target sum. If any two numbers in the input array sum up to the target sum, the function should return them in an array, in any order. If no two numbers sum up to the target sum, the function should return an empty array. . The two numbers must be two distinct integers in the array, you cannot add a single integer to itself in order to obtain the target sum . Assume that there will be at most one pair of numbers summing up to the target sum. . Understand . Input: array = [1,4,2,6], targetSum = 3 Output: [1,2] . Input: array = [2,3,1,4] targetSum = 5 Output: Not a valid test case . Input: array = [], targetSum = 10 Output: Not a valid test case . Input: array = [9,3,2,1], targetSum=0 Output: Not a valid test case . Input: array = [3], targetSum = 4 Output: Not a valid test case . Match and plan . List . given input is a list, so we have to iterate through the list to arrive at the solution | let us look at how does one of the solutions looks like and it’s complexity . Plan . // for i in 0-len(array): # t: O(n) // for j in i+1-len(array): # t: O(n) // if array[i] + array[j] == targetSum return [array[i], array[j]] . Complexity: time: O(n2), where n = len(array) | space: O(1) | . | . | we could in operator as follows . | Plan . // result = [] // for num in array: # t: O(n) // if (targetSum - num) in array and (targetSum - num) != num: # t: O(n) in operation result-&gt;add[num, (targetSum-num)] return result return result . Complexity: time: O(n2), where n=len(array) | space: O(1) | . | . | . | . Linked list . complicates the solution | . Hash-set . we can solve this problem using set, where you just have to remember if you have seen the difference before while iterating through the list, if yes return the two numbers if not then add the number to the set | don’t look for the the second number just look for the difference, inspired from the image Plan . // hashset = set() , result = [] # s: O(n), O(1) // for 0-len(array) # t: O(n) if targetSum-array[i] in hashset: # t: O(1) return array[i], targetSum-array[i] else hashset(array[i]) # t: O(1) . Complexity: time: O(n) + O(1) + O(1) -&gt; O(n), n=len(array) | space: O(n) | . | . | . | . Stack or Queue . not required to maintain any order | . Heaps . useful if we were to check for the top k elements | . Technique . Two pointers . | idea behind using two pointers: . if we have a sorted array, we can place a start pointer at the first number of the array end pointer at the last number in the array | check if array[start] + array[end] == targetSum | if start is incremented by 1 will increment the sum(array[start] + array[end]) | where as decrementing the end by 1 will reduce the sum(array[start] + array[end]) | with this information we can obtain the list of two numbers ([array[start], array[end]]) which sum up to the targetSum . | Plan // result = [] // sort the array # t: O(n log(n)) // using points look for the two numbers whose sum = targetSum // return the two numbers . Complexity: time: O(n), where n = len(array) | space: O(1) | . | . | . | . Implement . let us implement all the above discussed solutions | . # this an O(n^2) solution def two_number_sum(array, targetSum): for i in 0-len(array): # t: O(n) for j in i+1-len(array): # t: O(n) if array[i] + array[j] == targetSum return [array[i], array[j]] return [] . time: O(n2), where n = len(array) | space: O(1) | . # O(n^2) solution def two_number_sum(array, targetSum): result = [] for num in array: if (targetSum - num) in array and (targetSum - num) != num: result.extend([num, (targetSum-num)]) return result return result . time: O(n2) | space: O(1) | . # O(n) solution def two_number_sum(array, targetSum): array = sorted(array) start = 0 end = len(array) - 1 while start &lt; end: current_sum = array[start] + array[end] if current_sum == targetSum: return [array[start], array[end]] elif current_sum &lt; targetSum: start += 1 elif current_sum &gt; targetSum: right -= 1 return [] . time: O(n), where n = len(array) | space: O(1) | . # O(n) solution using hashset def twoNumberSum(array, targetSum): temp = set() for i in range(len(array)): if targetSum-(array[i]) in temp: return array[i], targetSum-array[i] else: temp.add(array[i]) return [] . time: O(n) | space: O(n) | . Evaluate . this problem has solution of varied time and space complexity | before implementation we have decide on space and time trade off | .",
            "url": "https://archanakalburgi.github.io/code_challenges/two_number_sum/array/2021/08/16/two-number-sum.html",
            "relUrl": "/two_number_sum/array/2021/08/16/two-number-sum.html",
            "date": " • Aug 16, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "Traverse a matrix to perform flood fill",
            "content": "Solving the following problem helped me better understand how to traverse a matrix and how to get the valid neighbors of a cell in the matrix . . Problem statement . An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image. . You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc]. . To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with newColor. . Return the modified image after performing the flood fill. . Understand . Input: image = [[1,0,1,1],[1,1,1,1]] , sr=1, sc=1, newColor=2 . . Output: [[2,0,2,2],[2,2,2,2]] . . Explanation: we have to perform flood fill from the cell with row = sr and column = sc | in this example we can perform flood fill on the cells left, right and above the cell (sr,sc) and change their values to newColor only if image[row][col] == image[sr][sc] | since the image[sr-1][sc] != image[sr][sc], we do not change it’s value | change the values of the neighbors of the cells you visit | . | . Input: image = [1,1,1]], sr=0, sc=1, newColor=2 Output: [[2,2,2]] . Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] . Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2 Output: [[2,2,2],[2,2,2]] . Match . Techniques . since it’s already given that we have to consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, we can perform either DFS or BFS from image[sr][sc] and reach it’s valid neighbor to change the value to newColor | in this post we will look at both bfs and dfs implementation | we change the value only if the value of the is equal to image[sr][sc] value | . Plan . def function(image, sr, sc, newColor): source = image[sr][sc] image[sr][sc] = newColor call dfs on image[sr][sc] return image def dfs(): dfs from sr,sc get valid neighbors for (sr,sc) if image[row][col] == source: image[row][col] = newColor def bfs(): . Implement . class Flood_fill: def valid_neighbors(self, r,c,image): valid = [] neighbors = [(r+1,c),(r-1,c),(r,c+1),(r,c-1)] for (nr,nc) in neighbors: if len(image) &gt; nr &gt;= 0 and len(image[0]) &gt; nc &gt;= 0: valid.append((nr,nc)) return valid def dfs(self, row, col, source, image, color, visited): for (nr,nc) in self.valid_neighbors(row, col, image): if (nr,nc) not in visited: visited.add((nr,nc)) if image[nr][nc] == source: image[nr][nc] = color self.dfs(nr,nc,source,image, color, visited) def bfs(self, row, col, image, visited, source, color): queue = [(row, col)] while queue: r, c = queue.pop(0) for (nr,nc) in self.valid_neighbors(r, c, image): if (nr,nc) not in visited: if image[nr][nc] == source: image[nr][nc] = color queue.append((nr,nc)) visited.add((nr,nc)) def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -&gt; List[List[int]]: source = image[sr][sc] image[sr][sc] = newColor for row in range(len(image)): for col in range(len(image[0])): if row==sr and col==sc: self.dfs(row, col, source, image, newColor, set()) # to call bfs visited = set() self.bfs(row, col, image, visited, source, newColor) visited.add((row,col)) return image . Review . consider the input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2 | the bfs traversal of the matrix is shown in the figure below the numbers in green and that are circled represent the order in which the cells are visited | . | status of the queue while doing a bfs traversal 1 1 [(2, 1), (0, 1), (1, 2), (1, 0)] 0 1 [(1, 1), (0, 2), (0, 0)] 1 0 [(2, 0), (0, 0), (1, 1)] 0 2 [(1, 2), (0, 1)] 0 0 [(1, 0), (0, 1)] 2 0 [(1, 0), (2, 1)] . | the dfs traversal of the matrix is shown in the figure below the numbers in green and that are circled represent the order in which the cells are visited | . | status of the stack while doing a dfs traversal 1 1 [(2, 1), (0, 1), (1, 2), (1, 0)] 0 1 [(2, 1), (0, 1), (1, 2), (1, 0)] 0 2 [(1, 1), (0, 2), (0, 0)] 0 0 [(1, 1), (0, 2), (0, 0)] 1 0 [(1, 0), (0, 1)] 2 0 [(2, 0), (0, 0), (1, 1)] | . Evaluate . complexity: time: O(n) where n=number of pixels in the image | space: O(n) size of call stack while calling dfs | . | .",
            "url": "https://archanakalburgi.github.io/code_challenges/grid/graph/dfs/bfs/2021/08/15/flood-fill.html",
            "relUrl": "/grid/graph/dfs/bfs/2021/08/15/flood-fill.html",
            "date": " • Aug 15, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "Kth largest value of binary search tree",
            "content": "The following problem helped me understand that in-order traversal of a binary search tree yields a sorted array. . . image source . Problem statement . Write a function that takes in a Binary Search Tree(BST) and a positive integer k and returns the kth largest integer contained in the BST . Assume the following: . there will only be integer values in the BST | k &lt;= number of nodes in the BST | if tree = [5, 7, 7] second largest value of the BST will be 7 and not 5 | . Understand . Input: [15, 5, 20, 2, 5, 17, 22, 1, 3],k = 3 Output: 17 Explanation: after 22 and 20, 17 is the largest values in the given BST . Input: [1], k=1 Output: 1 . Input: [1], k=2 Output: not a valid case . Input: [2,1,3], k=3 Output: 3 . Input: [1,null,2,null,3,null,4], k=0 Output: Not a valid case . Match . List . // traverse tree build node_list // sort nodes_list in descending order // return node_list[k] . complexity: time: O(n)+O(n log n) -&gt; O(n log n) | space: O(n) | . | . Linked list . using linked list will cost us extra time to create a liked list | . Hashmap asd Hashset . both the data structure are not useful for solving the problem | . Stack and Queue . we are not required to look for or maintain LIFO or FIFO order | . Heap . Heap are very helpful to find the kth largest or kth smallest elements // create max heap // pop k times // return kth popped item . | complexity: time: O(n) + O(n log n) -&gt; O(n log n) | space: O(n) | . | all though with heap we can obtain the kth element, it did not improve the complexity of the algorithm that we came up by using list | . Techniques . we can traverse a tree using BFS or DFS | DFS has preorder, postorder and inorder traversal | . Exploring the traversals . let us consider out first example, tree = [15,5,20,2,5,17,22,1,3] and check the order of the nodes that we visit with each traversal | . Breadth first search . bfs traversal of BST = [[1],[2,3],[5,5,15,17],[20,22]] | . Preorder traversal . preorder traversal of BST = [15,5,20,2,5,17,22,1,3] is [15,5,2,1,3,5,20,17,22] | . Postorder traversal . postorder traversal of BST = [15,5,20,2,5,17,22,1,3] is [1,3,2,5,5,17,22,20,15] | . Inorder traversal . inorder traversal of BST = [15,5,20,2,5,17,22,1,3] is [1,2,3,5,5,15,17,20,22] . | comparing all the traversals it is safe to conclude that in-order traversal yields a sorted array | taking advantage of this property we can arrive at the solution arrive at the solution | high level steps involved are traverse tree in inorder fashion - build array of nodes | return array[len(array)-k] | . | . // dfs - inorder recursive // list of nodes // return kth element from end . complexity: time: O(n) | space: O(n)+O(n) -&gt; O(n) | . | we could traverse the tree in reverse in-order to get the list of values in descending order | we can do so by adding left child on to the stack an then the right child so the right child is processed before the left child | . // reverse in-order -&gt; recursion // list of nodes // return kth element . complexity: time: O(n) | space: O(n)+O(n) | . | . Implementation . class BST: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def reverse_inorder(root, array, k): if root == None: return None node = root stack = [node] while stack: if node == None: node = stack.pop() array.append(node.value) node = node.left else: stack.append(node) node = node.right def findKthLargestValueInBst(tree, k): if tree == None: return None nodes_list = [] reverse_inorder(tree, nodes_list, k) return nodes_list[k-1] . Review . for the input tree [15, 5, 20, 2, 5, 17, 22, 1, 3] and k = 3 nodes_list = [22, 20, 17, 15, 5, 5, 3, 2, 1, 15] | . | . Evaluate: . complexity: traverse tree -&gt; time: O(n) | nodes_list + call stack -&gt; space: O(n)+O(n) | . | .",
            "url": "https://archanakalburgi.github.io/code_challenges/bst/dfs/inorder/2021/08/14/kth-largest-in-bst.html",
            "relUrl": "/bst/dfs/inorder/2021/08/14/kth-largest-in-bst.html",
            "date": " • Aug 14, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "Binary tree to a linked list",
            "content": "I found this problem interesting because it combines the concept of linked list and binary tree traversal. . . Problem statement . Given the root of a binary tree, flatten the tree into a “linked list”: . The “linked list” should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null. . | The “linked list” should be in the same order as a pre-order traversal of the binary tree. . | . Understand . Example 1: . Input: . Output: . Example 2: . Input: . Output: . Example 3: . Input: . Output: . Match . Lists . // traverse tree: preorder.append(nodes) // traverse preorder: build linked list . we could implement this algorithm using list | however this might not be the ideal solution since the linked list should use the same TreeNode class. | complexity time: O(n) + O(n) ≈ O(n) | space: O(n) + O(n) ≈ O(n) | . | . Techniques . To solve a problem related to binary tree, it is a good idea to explore the techniques as well . two ways we could traverse a binary tree are BFS and DFS | since the linked list must be same as a pre-order traversal of the binary tree we need to traverse the tree in a pre-order traversal | . Plan . we will have to process nodes in a pre-order fashion and rewire the tree such that each node’s left is pointing to null and right pointer points to the left child of the node | in order to traverse a tree DFS way, we have to traverse the entire branch of the tree and then the adjacent nodes | in order to keep track of the node to be processed next it requires last in first out approach which can be tracked using a stack | once the depth is reached the nodes are popped out of stack | in oder to do so we will initialize a stack, with it’s first entry being the root of the given binary tree | for every node, if a node has a left child, make it null | make the node the new right child of the previous node | . | . // initialize temp = tree node // traverse tree iteratively node = root temp.left_chid = None temp.right_child = node temp = temp.right_child . Implement . def flatten(root: TreeNode) -&gt; None: if root == None: return None temp = TreeNode() node_stack = [root] while node_stack : node = node_stack.pop() temp.left = None temp.right = node if node.right: node_stack.append(node.right) if node.left: node_stack.append(node.left) temp = temp.right . Review . Consider the following input . . Output would be . . Evaluate . Complexity: . time: O(n) | space: O(n) | .",
            "url": "https://archanakalburgi.github.io/code_challenges/binary_tree/preorder/linked_list/2021/08/11/BT-to-LL.html",
            "relUrl": "/binary_tree/preorder/linked_list/2021/08/11/BT-to-LL.html",
            "date": " • Aug 11, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "Find the town judge",
            "content": "Here is an interesting problem that I enjoyed solving using UMPIRE method. . . Problem statement . In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge. . If the town judge exists, then: . The town judge trusts nobody. | Everybody (except for the town judge) trusts the town judge. | . There is exactly one person that satisfies properties 1 and 2. . You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. . Return the label of the town judge if the town judge exists and can be identified, or return -1 otherwise. . For Example: . For n = 2 and trust = [[1,2]] return 2, because 1 trusts 2, 2 trusts no one | . Understand . Happy cases: . Input: n = 3, trust = [[1,2],[3,2]] Output: 2 . Input: n = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]] Output: 3 . Input: n = 4, trust = [[1,2],[2,4],[3,4],[1,4]] Output: 4 . Input: n = 3, trust = [[1,2],[2,3]] Output: -1 . Input: n = 3, trust = [[1,3],[2,3],[3,1]] Output: -1 . Input: n = 2, trust = [[1,2],[2,1]] Output: -1 . Input: n = 5, trust = [[1,3],[1,2],[1,4],[1,5]] Output: -1 . Match . Lists: . // iterate _trust_ to create a list of list, list[i] = list of people i trusts, // find a member common to all the lists (town judge) // if no common member found: return -1 . complexity: time: O(n), where n = len(trust) time to traverse trust array | . | space: O(m2), where m = n for example, if n = 5, trust = [[1,2],[1,3],[1,4],[1,5],[2,1],[2,3],[2,4],[2,5],[3,1],[3,2],[3,4],[3,5],[4,1],[4,2],[4,3],[4,5],[5,1],[5,2],[5,3],[5,4]] | after iterating through trust we will have a list = [[2,3,4,5],[1,3,4,5],[1,2,4,5],[1,2,3,5],[1,2,3,4]] | space = O(m*m-1) ≈ O(m2), where m = n | . | . | . Linked List . linked list will not optimize the m2 complexity | . Stack and Queue . stacks and Queue data structure help us in maintaining LIFO or FIFO order | the problem does not require us to look or maintain LIFO or FIFO order | so it’s better to avoid stack or queue | . Heap . Since we are not required to sort, heap will not be useful to solve this problem | . Hashmap . Oh, yes hashmaps!! | we could have n keys whose values can be the people a particular person trusts | since every person is unique, the keys are unique | also, there is no need to maintain the order of people | plus hashmaps have constant time look up, which will make our solution faster | so hashmap it is! | . Plan . build a hashmap, where keys are the people ranging from 1-n and the values are can the appended looking up the trust array | in other words we are building a graph | the relation between the nodes is given in the trust array | the first property, the town judge trusts nobody, makes town judge a sink node, and | the second property, everybody (except for the town judge) trusts the town judge, essentially tells that all the nodes in the graph are connected to the sink node | this is clearly a dependency graph problem | steps involved: // construct a graph // if sink node not found: return -1 // if sink node present: if all nodes are not connected to sink node: return -1 // return sink node . | . Implement . def findJudge(n: int, trust: List[List[int]]) -&gt; int: graph = dict() in_degree = dict() # to find sink node judge = -1 for i in range(1,n+1): # O(n) graph[i] = set() in_degree[i] = 0 for edge in trust: # O(t) graph[edge[0]].add(edge[1]) in_degree[edge[0]] += 1 for key in in_degree.keys(): # O(n) if in_degree[key]==0: # only one sink node, only one judge per town judge = key for key in graph.keys():# O(n) if judge not in graph[key] and key!=judge: # in order to exclude the judge himself return -1 return judge . Review . Input: n = 2, trust = [[1,2]] . for this problem, graph = {1: {2}, 2: set()} | in_degree = {1: 1, 2: 0} | judge = 2 (in_degree[2]==0) | . | . Output: 2 . Evaluate . time: n + t + n + n ~ O(3n + t) ~ O(n + t) if t « n ~ O(n) | where n = n(number of people) and t = len(trust) | . | space: O(n) graph and in_degree | . | .",
            "url": "https://archanakalburgi.github.io/code_challenges/graph/in_degree/2021/08/05/find-the-town-judge.html",
            "relUrl": "/graph/in_degree/2021/08/05/find-the-town-judge.html",
            "date": " • Aug 5, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "",
          "url": "https://archanakalburgi.github.io/code_challenges/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "Back to Tuktuk",
          "content": "Redirecting to Code Challenges Page... Redirecting to Tuktuk home page...",
          "url": "https://archanakalburgi.github.io/code_challenges/_pages/back_to_tuktuk.html",
          "relUrl": "/_pages/back_to_tuktuk.html",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://archanakalburgi.github.io/code_challenges/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}