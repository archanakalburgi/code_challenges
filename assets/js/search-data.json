{
  
    
        "post0": {
            "title": "Number of tiny pairs",
            "content": "Problem . You are given two arrays of integers and b of the same length, and an integer k. We will be iterating through array a from left to right, and simultaneously through array b from right to left, and looking at pairs (x, y) where x is from a and y is from b. Such pair iS called tiny if the concatenation xy is strictly less than k . Your task is to return the number of tiny pairs that you’ll encounter during the simultaneous iteration through a and b. . Example . Example 1 . For [1, 2, 3] b = (1, 2, 3) and k = 31 , the output should be solution(a, b, k) = 2 . We’re considering the following pairs during iteration: . (1, 3) : Their concatenation equals 13, which is less than 31 SO the pair iS tiny; | (2 2) : Their concatenation equals 22 , which is less than 31 so the IS pair is tiny; | (3, 1) : Their concatenation equals 31 which is not less than 31 so the pair is not tiny. | . As you can see, there are 2 tiny pairs during the iteration, so the answer is 2. . Example 2 . For a[16, 14] , b = [7, 11, 2, 15] , and k = 743 , the output should be solution (a, b, k) = 4 . We’re considering the Following pairs during iteration: . (16, 15) : Their concatenation equals 1615 , which is greater than 743, so the pair is not tiny; | (1, 0) : Their concatenation equals 10 , which is less than 743, so the pair is tiny; | (4, 2) : Their concatenation equals 42 , which is less than 743, so the pair is tiny. | (2, 11) : Their concatenation equals 211 , which is less than 743, so the pair is tiny; | (14, 7) : Their concatenation equals 147 which is less than 743 , so the pair is tiny. | . There are 4 tiny pairs during the iteration. So the answer is 4 . Pseudocode . fun (a[i], b[j], k) str_a = str(a[i]) str_b = srt(b[i]) res_str = str_a + str_b return int(res_str) &lt; k main() i=0, j=len (b) =1 while i&lt;len(a) and j&lt;=0: if fun(a[i], b[i], k): count++ i+=1, j-=1 return count . Implementation . def helper(a, b, k): str_a = str(a) str_b = str(b) res_str = str_a + str_b return int(res str) &lt; k def solution(a, b, k): i = 0 j = len(b)-1 count = 0 while i&lt;len(a) and j&gt;=0: if helper(a[i], b[j], k): count = count+1 i+=1 j-=1 return count .",
            "url": "https://archanakalburgi.github.io/code_challenges/markdown/2022/01/21/tiny_pairs.html",
            "relUrl": "/markdown/2022/01/21/tiny_pairs.html",
            "date": " • Jan 21, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Calculate a boolean array",
            "content": "Question . You are given an array of integers a and two integers l and r. You task is to calculate a boolean array b, where b[i] = true if there exists an integer x, such that a[i] = (i + 1) * x and l&lt;= x &lt;= r. Otherwise, b[i] should be set to false . Example . For a = [8, 5, 6, 16, 51], l = 1, and r = 3, the output should be solution (a, l, r) = [false, false, true, false, true]. . For a[0] = 8 , we need to find a value of x such that 1 * x = 8, but the only value that would work is x = 8 which doesn’t satisfy the boundaries 1 &lt;= x &lt;= 3, so b[0] = false. | For a[1] = 5, we need to find a value of x such that 2 * x = 5, but there is no integer value that would satisfy this equation, so b[1] = false | For a[2] = 6, we can choose x because 3 * 2 = 6 and 1 &lt;= 2 &lt;= 3, so b[2] = true | For a[3] = 16, there is no an integer 1 &lt;= x &lt;= 3 , such that 4 * x = 16, so b[3] = false. | For a[4] = 5, we can choose x = 1 because 5 * 1 = 5 and 1 &lt;= 1 &lt;= 3 , so b[4] = true. | . Guaranteed constraints: . 1 &lt;= a.length &lt;= 100 | 1 &lt;= a[i] &lt;= 10^6 | 1 &lt;= l &lt;= 10^4 | 1 &lt;= r &lt;= 10^4 | . Pseudocode . func (i, a[i], l, r): for x in range(l, r+1): if (i+1)*x == a[i]: return true return false main() iterate a fun (i,ali], l,r)-&gt; t b=&gt; append bool return b . Implementation . def helper (i, num, l, r): for in range(l, r+1): if (i+1)*x == num: return True return False def solution(a, l, r): b = list() for i in range(len(a)): res = helper(i, a[i], l, r) b.append(res) return b .",
            "url": "https://archanakalburgi.github.io/code_challenges/markdown/2022/01/21/contruct_array.html",
            "relUrl": "/markdown/2022/01/21/contruct_array.html",
            "date": " • Jan 21, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Find and Replace Pattern",
            "content": "Problem statements . Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order. . A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. . Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter. . Examples . Example 1: . Input: words = [“abc”,”deq”,”mee”,”aqq”,”dkd”,”ccc”], pattern = “abb” Output: [“mee”,”aqq”] Explanation: “mee” matches the pattern because there is a permutation {a -&gt; m, b -&gt; e, …}. “ccc” does not match the pattern because {a -&gt; c, b -&gt; c, …} is not a permutation, since a and b map to the same letter. . Example 2: . Input: words = [“a”,”b”,”c”], pattern = “a” Output: [“a”,”b”,”c”] . Solution using UMPIRE . Test cases . words = [qnr, anr, nmr] pattern = xnr output = [ qnr, anr, nmr ] words = [] -&gt; X pattern = pq words = [p, f, b] -&gt; X pattern = &quot;&quot; words = [ab, dg, pn] -&gt; X pattern = abc words = [ASD, 990] -&gt; X patter -&gt; 889 -&gt; X words = [abc, pqr] patter = rrr output = [ ] words = [&quot;abcde&quot;,&quot;meeme&quot;] pattern = &quot;abbab&quot; . Match and Plan . abbab a:0,3 b:1,2,4 meeme m:0,3 e:1,2,4 . helper(string): map = {} res = &quot;&quot; iterate string: i if string[i] in map: map[string]: ..i else map[string]:i iterate string: s res += map[s] return res main() result=[] pattern_encoded = helper(pattern) iterate words: word word_pattern = helper(word) if word_pattern == pattern_encoded: result: add - word return result . Implement . class Solution: def helper(self, string): mapping = dict() encoded_pattern = &quot;&quot; for i in range(len(string)): if string[i] in mapping: mapping[string[i]].append(i) else: mapping[string[i]] = [i] for s in string: for i in mapping[s]: encoded_pattern += str(i) return encoded_pattern def findAndReplacePattern(self, words: List[str], pattern: str) -&gt; List[str]: result = list() pattern_encoded = self.helper(pattern) for word in words: word_encoded = self.helper(word) if len(word) == len(pattern) and word_encoded == pattern_encoded: result.append(word) return result . Review and Evaluate . Complexity : Let N = length of words and K = length of each word in words . Time complexity: O(N*K) | . | Space complexity: O(N*K) | . | .",
            "url": "https://archanakalburgi.github.io/code_challenges/markdown/2022/01/18/find_pattern.html",
            "relUrl": "/markdown/2022/01/18/find_pattern.html",
            "date": " • Jan 18, 2022"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://archanakalburgi.github.io/code_challenges/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "Back to Tuktuk",
          "content": "Redirecting to Code Challenges Page... Redirecting to Tuktuk home page...",
          "url": "https://archanakalburgi.github.io/code_challenges/_pages/back_to_tuktuk.html",
          "relUrl": "/_pages/back_to_tuktuk.html",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://archanakalburgi.github.io/code_challenges/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}